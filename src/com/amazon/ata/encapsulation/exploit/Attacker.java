package com.amazon.ata.encapsulation.exploit;

import com.amazon.ata.encapsulation.model.CustomerPaymentInstruments;
import com.amazon.ata.encapsulation.model.PaymentInstrument;

import java.math.BigDecimal;

/**
 * This class contains code that an attacker could execute within Amazon's
 * systems.
 * <p>
 * IMPLEMENT METHODS IN THIS CLASS REPRESENTING ATTACKS.
 * <p>
 * One method has been provided representing one possible attack. You can
 * demonstrate the attack by running the {@code PaymentSelector} tests.
 * <p>
 * Don't change the name of the methods below (so you can avoid changing the {@code PaymentSelectorTest} class's
 * methods, but you can certainly add attacks here (and add corresponding tests to {@code PaymentSelectorTest})
 */
public class Attacker {
    /**
     * Renders the zero-th payment instrument unusable.
     *
     * @param customerInstruments The CustomerPaymentInstruments to attack
     */
    public void depleteFirstInstrumentFunds(final CustomerPaymentInstruments customerInstruments) {
        final PaymentInstrument[] paymentInstruments = customerInstruments.getPaymentInstruments();
        paymentInstruments[0].setAvailableFunds(new BigDecimal("-1"));
    }

    /**
     * COMPLETION 1: When you've got this implemented, run the corresponding JUnit test in PaymentSelectorTest and
     * verify that it fails in the way expected. To create the exploit,
     * implement this method so that it:
     * <p>
     * Artificially inflates the purchasing power of the zero-th PaymentInstrument by
     * replacing it.
     *
     * Hint: see if you can do this by creating your own PaymentInstrument and overwrite
     * the one in the zero-index spot.
     *
     * @param customerInstruments A customer's preferred PaymentInstruments
     */
    public void replaceFirstInstrumentWithMoreFunds(final CustomerPaymentInstruments customerInstruments) {
        PaymentInstrument[] paymentInstruments = customerInstruments.getPaymentInstruments();
        PaymentInstrument copy = new PaymentInstrument(paymentInstruments[0].getInstrumentId());
        copy.setInstrumentType(paymentInstruments[0].getInstrumentType());
        copy.setAvailableFunds(new BigDecimal(10000));
        paymentInstruments[0] = copy;
        // PARTICIPANTS: implement the attack here
    }

    /**
     * COMPLETION 2: When you've got this implemented, run the corresponding JUnit test in PaymentSelectorTest and
     * verify that it fails in the way expected. To create the exploit,
     * implement this method so that it:
     * <p>
     * Subverts customer PaymentInstrument preferences by reordering them, frustrating customers.
     *
     * Hint: to swap two entries in an array, consider using a local variable to
     * store entry A while you overwrite entry A with entry B. Then overwrite entry B
     * with the value in the local variable.
     *
     * @param customerInstruments A customer's preferred (in order) PaymentInstruments
     */
    public void reorderPaymentInstruments(final CustomerPaymentInstruments customerInstruments) {
        PaymentInstrument [] paymentInstruments = customerInstruments.getPaymentInstruments();
        PaymentInstrument temp = paymentInstruments[0];
        paymentInstruments[0] = paymentInstruments[1];
        paymentInstruments[1] = temp;
        // PARTICIPANTS: implement the attack here
    }

    /**
     * EXTENSION 1:  When you've got this implemented, run the corresponding JUnit test in PaymentSelectorTest and
     * verify that it fails in the way expected. To create the exploit,
     * implement this method so that it:
     * <p>
     * Configures payment instruments such that customer1 can use customer2's credit card instrument.
     *
     * @param customer1Instruments A customer's preferred payment instruments.
     * @param customer2Instruments Another customer's preferred payment instruments.
     */
    public void grantCustomerAccessToAnotherCustomersInstruments(
            final CustomerPaymentInstruments customer1Instruments,
            final CustomerPaymentInstruments customer2Instruments) {
        // PARTICIPANTS: implement the attack here
    }

    /**
     * EXTENSION 2: When you've got this implemented, run the corresponding JUnit test in PaymentSelectorTest and
     * verify that it fails in the way expected. To create the exploit,
     * implement this method so that it:
     * <p>
     * Removes all of a customer's payment instruments from their preferred list so that they're unusable.
     *
     * @param customerInstruments A customer's preferred payment instruments
     */
    public void destroyPaymentInstruments(final CustomerPaymentInstruments customerInstruments) {
        // PARTICIPANTS: implement the attack here
    }

    /**
     * EXTENSION 3: Rename this to match what your attack exploits, create a new test to PaymentSelectorTest and ensure
     * that it fails in the way you expect.
     *
     * @param customer1Instruments A customer's preferred payment instruments.
     * @param customer2Instruments Another customer's preferred payment instruments.
     */
    public void attack6(final CustomerPaymentInstruments customer1Instruments,
                        final CustomerPaymentInstruments customer2Instruments) {

        // PARTICIPANTS: implement the attack here, then add corresponding test to PaymentSelectorTest
        // RECOMMENDED: change this method name to describe the nature of your attack
    }

    // PARTICIPANTS: EXTENSION 3+ feel free to add more attack methods if you think of any!
}
